name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DEPLOY_HOST: kanban.pearachute.com
  DEPLOY_USER: kanban
  DEPLOY_PATH: /opt/kanban

jobs:
  # First, run tests to ensure we don't deploy broken code
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install CLI dependencies
        run: |
          pip install -e ./kanban

      - name: Run backend tests
        working-directory: ./backend
        run: |
          pytest

      - name: Run CLI tests
        working-directory: ./backend
        run: |
          pytest tests/test_cli.py

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build

  # Check if deployment is actually needed
  check-changes:
    name: Check for Deployment Changes
    runs-on: ubuntu-latest
    needs: test
    outputs:
      deploy_needed: ${{ steps.changes.outputs.deploy_needed }}
      frontend_changed: ${{ steps.changes.outputs.frontend_changed }}
      backend_changed: ${{ steps.changes.outputs.backend_changed }}
      config_changed: ${{ steps.changes.outputs.config_changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for relevant changes
        id: changes
        run: |
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "deploy_needed=true" >> $GITHUB_OUTPUT
            echo "frontend_changed=true" >> $GITHUB_OUTPUT
            echo "backend_changed=true" >> $GITHUB_OUTPUT
            echo "config_changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get the list of changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          
          frontend_changed=false
          backend_changed=false
          config_changed=false
          deploy_needed=false

          # Check frontend changes
          if echo "$CHANGED_FILES" | grep -q "^frontend/"; then
            frontend_changed=true
            deploy_needed=true
          fi

          # Check backend changes
          if echo "$CHANGED_FILES" | grep -E "^backend/|^manage\.py$"; then
            backend_changed=true
            deploy_needed=true
          fi

          # Check deployment configuration changes
          if echo "$CHANGED_FILES" | grep -E "^sys/"; then
            config_changed=true
            deploy_needed=true
          fi

          echo "deploy_needed=$deploy_needed" >> $GITHUB_OUTPUT
          echo "frontend_changed=$frontend_changed" >> $GITHUB_OUTPUT
          echo "backend_changed=$backend_changed" >> $GITHUB_OUTPUT
          echo "config_changed=$config_changed" >> $GITHUB_OUTPUT

          echo "Changes detected:"
          echo "  Frontend: $frontend_changed"
          echo "  Backend: $backend_changed"
          echo "  Config: $config_changed"
          echo "  Deploy needed: $deploy_needed"

  # Create database backup before deployment (handled by deploy script)
  # This step is now handled within the deploy script

  # Deploy to production
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, check-changes]
    if: needs.check-changes.outputs.deploy_needed == 'true'
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            echo "üöÄ Starting deployment to production..."
            
            # Run the existing deploy script - it handles everything!
            cd ${{ env.DEPLOY_PATH }}
            sys/scripts/deploy.sh

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Wait for service to be fully ready
          sleep 10
          
          # Check if the application is responding
          if curl -f -s -o /dev/null -w "%{http_code}" https://kanban.pearachute.com/api/health | grep -q "200\|404"; then
            echo "‚úÖ Application is responding"
          else
            echo "‚ùå Application is not responding"
            curl -I https://kanban.pearachute.com
            exit 1
          fi

  # Post-deployment notifications
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [test, check-changes, deploy]
    if: always() && needs.check-changes.outputs.deploy_needed == 'true'
    steps:
      - name: Get deployment status
        id: status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=üéâ Production deployment completed successfully!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Production deployment failed!" >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR (if applicable)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          script: |
            const message = `${{ steps.status.outputs.message }}
            
            **Changes deployed:**
            - Frontend: ${{ needs.check-changes.outputs.frontend_changed }}
            - Backend: ${{ needs.check-changes.outputs.backend_changed }}
            - Configuration: ${{ needs.check-changes.outputs.config_changed }}
            
            **Commit:** ${{ github.sha }}
            **Deployed by:** ${{ github.actor }}
            
            üåê **Live at:** https://kanban.pearachute.com`;
            
            // Find any open PRs that might be related to this push
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: 'main'
            });
            
            for (const pr of pulls) {
              if (pr.head.sha === context.sha) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: message
                });
                break;
              }
            }